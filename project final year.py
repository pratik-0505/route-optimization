# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oFozO7_vJuLhFIMW_pzGttGkkngpsDXH
"""

# Install necessary packages (Run this only if you haven't installed them)
!pip install osmnx networkx ortools folium plotly

# Import required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import folium
import plotly.express as px
import osmnx as ox
import networkx as nx
from ortools.constraint_solver import pywrapcp
from ortools.constraint_solver import routing_enums_pb2

city = "London"
dtf=pd.read_csv('data_stores.csv')
dtf=dtf[dtf["City"]==city][ ["City", "Street Address", "Latitude", "Longitude"]].reset_index(drop=True)
dtf=dtf.reset_index().rename(columns={"index":"id", "Latitude":"y", "Longitude":"x"})

print("total", len(dtf))
dtf.head(3)

data = dtf.copy()
data["color"]=''
data.loc[data['id']==0 , 'color'] = 'red'
data.loc[data['id']!=0 , 'color'] = 'black'
start=data[data["id"]==0][["y","x"]].values[0]
data.head(3)
print("starting point:" , start)

map = folium.Map(location=start, tiles= "cartodbpositron", zoom_start=12)
data.apply(lambda row:
    folium.CircleMarker(
        location=[row["y"], row["x"]],
        color=row["color"], fill = True, radius=5).add_to(map), axis=1)

map

G=ox.graph_from_point(start, dist=10000, network_type="drive")
G=ox.add_edge_speeds(G)
G=ox.add_edge_travel_times(G)
fig,ax = ox.plot_graph(G, bgcolor="black", node_size=5 , node_color="white", figsize=(16,8))

start_node=ox.distance.nearest_nodes(G, start[1], start[0])
dtf["node"]=dtf[["y", "x"]].apply(lambda x: ox.distance.nearest_nodes(G, x[1], x[0]), axis=1)
dtf=dtf.drop_duplicates("node", keep='first')
dtf.head()

def f(a , b):
    try:
        d=nx.shortest_path_length(G, source=a, target=b, method='dijkstra', weight='travel_time')
    except:
        d=np.nan
    return d

distance_matrix=np.asarray([[f(a,b)for b in dtf["node"].tolist()] for a in dtf["node"].tolist()])
distance_matrix=pd.DataFrame(distance_matrix, columns=dtf["node"].values, index=dtf["node"].values)

distance_matrix.head()

heatmap= distance_matrix.copy()
for col in heatmap.columns:
    heatmap[col]=heatmap[col].apply(lambda x:
         0.3 if pd.isnull(x) else
         (0.7 if np.isinf(x) else
          (0 if x!=0 else 1)) )

fig, ax = plt.subplots(figsize=(10,5))
sns.heatmap(heatmap, vmin=0 , vmax=1 , cbar=False, ax=ax)
plt.show()

distance_matrix= distance_matrix.round()
distance_matrix=distance_matrix.astype('int')
distance_matrix

drivers = 1
lst_nodes = dtf["node"].tolist()  # Define lst_nodes here
print("start:", start_node, "total locations to visit", len(lst_nodes)-1, "drivers", drivers)

manager = pywrapcp.RoutingIndexManager(len(lst_nodes), drivers, lst_nodes.index(start_node))
model = pywrapcp.RoutingModel(manager)

drivers = 1
lst_nodes= dtf["node"].tolist()
print("start:", start_node, "total locations to visit", len(lst_nodes)-1, "drivers", drivers)

def get_distance(from_index, to_index):
    return distance_matrix.iloc[from_index, to_index]

distance=model.RegisterTransitCallback(get_distance)
model.SetArcCostEvaluatorOfAllVehicles(distance)

parameters = pywrapcp.DefaultRoutingSearchParameters()
parameters.first_solution_strategy= (routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)

solution= model.SolveWithParameters(parameters)

index=model.Start(0)
print('route for driver:')
route_idx, route_distance = [], 0

while not model.IsEnd(index):
    route_idx.append(manager.IndexToNode(index))
    previous_index=index
    index=solution.Value(model.NextVar(index))

    try:
        route_distance +=get_distance(previous_index, index)
    except:
        route_distance+=model.GetArcCostForVehicle(from_index=previous_index, to_index=index, vehicle=0)

print(route_idx)
print(f'Total distance:{round(route_distance/1000,2)}km')
print(f'Nodes visited: {len(route_idx)}')

print("Route for driver (nodes):")
lst_route=[lst_nodes[i] for i in route_idx]
print(lst_route)

import osmnx as ox
import networkx as nx
import folium

# Function to find shortest paths between consecutive nodes
def get_path_between_nodes(lst_route, G):
    lst_paths = []
    for i in range(len(lst_route) - 1):
        try:
            a, b = lst_route[i], lst_route[i + 1]
            path = nx.shortest_path(G, source=a, target=b, method='dijkstra', weight='travel_time')
            if len(path) > 1:
                lst_paths.append(path)
        except nx.NetworkXNoPath:
            print(f"No path found between {a} and {b}")
            continue
        except Exception as e:
            print(f"Error finding path: {e}")
            continue
    return lst_paths

# Load a street network graph for a location (Modify as needed)
G = ox.graph_from_place("Manhattan, New York, USA", network_type="drive")

# Get a sample route (Modify as needed)
lst_route = list(G.nodes())[:5]  # Example: Taking first 5 nodes as route

# Compute the shortest paths
lst_paths = get_path_between_nodes(lst_route, G)

# Initialize a Folium map centered at the first node's location
start_node = lst_route[0]
start_lat, start_lon = G.nodes[start_node]['y'], G.nodes[start_node]['x']
my_map = folium.Map(location=[start_lat, start_lon], zoom_start=14)

# Function to add routes to the Folium map
def add_routes_to_folium(G, lst_paths, my_map):
    for path in lst_paths:
        route_coords = [(G.nodes[n]['y'], G.nodes[n]['x']) for n in path]
        folium.PolyLine(route_coords, color="blue", weight=3, opacity=0.7).add_to(my_map)

# Add computed routes to the map
add_routes_to_folium(G, lst_paths, my_map)

# Display the interactive map
my_map

def df_animation_multiple_path(G, lst_paths, parallel=True):
    df=pd.DataFrame()
    for path in lst_paths :
        lst_start, lst_end = [] , []
        start_x, start_y = [] , []
        end_x, end_y = [], []
        lst_length, lst_time = [], []

        for a , b in zip (path[:-1], path[1:]):
            lst_start.append(a)
            lst_end.append(b)
            lst_length.append(round(G.edges[(a,b,0)]['length']))
            lst_time.append(round(G.edges[(a,b,0)]['travel_time']))
            start_x.append(G.nodes[a]['x'])
            start_y.append(G.nodes[a]['y'])
            end_x.append(G.nodes[b]['x'])
            end_y.append(G.nodes[b]['y'])

        tmp=pd.DataFrame(list(zip(lst_start, lst_end, start_x, start_y, end_x, end_y, lst_length, lst_time)),
                         columns= ["start", "end", "start_x", "start_y", "end_x", "end_y", "length", "travel_time"])
        df=pd.concat([df,tmp], ignore_index=(not parallel))

    df=df.reset_index().rename(columns={"index":"id"})
    return df

import osmnx as ox
import networkx as nx
import pandas as pd

# Load a street network graph for a location (Modify as needed)
G = ox.graph_from_place("Manhattan, New York, USA", network_type="drive")

# Function to add missing 'travel_time' attribute
def add_travel_time(G, speed_kph=50):
    """Adds travel_time (in seconds) to the edges of a graph using speed in km/h."""
    for u, v, k, data in G.edges(keys=True, data=True):
        if 'length' in data:  # Ensure 'length' exists
            speed_mps = speed_kph * 1000 / 3600  # Convert km/h to m/s
            data['travel_time'] = data['length'] / speed_mps  # Compute travel time

# Add travel_time to the graph edges
add_travel_time(G, speed_kph=50)  # Adjust speed if needed

# Get a sample route (Modify as needed)
lst_route = list(G.nodes())[:5]  # Example: Taking first 5 nodes as route

# Compute shortest paths
def get_path_between_nodes(lst_route, G):
    lst_paths = []
    for i in range(len(lst_route) - 1):
        try:
            a, b = lst_route[i], lst_route[i + 1]
            path = nx.shortest_path(G, source=a, target=b, method='dijkstra', weight='travel_time')
            if len(path) > 1:
                lst_paths.append(path)
        except nx.NetworkXNoPath:
            print(f"No path found between {a} and {b}")
            continue
        except Exception as e:
            print(f"Error finding path: {e}")
            continue
    return lst_paths

lst_paths = get_path_between_nodes(lst_route, G)

# Fix the function handling DataFrame creation
def df_animation_multiple_path(G, lst_paths, parallel=False):
    """Generates a DataFrame with route data, ensuring 'travel_time' exists."""
    lst_start, lst_end, lst_length, lst_time = [], [], [], []
    start_x, start_y, end_x, end_y = [], [], [], []

    for path in lst_paths:
        for i in range(len(path) - 1):
            a, b = path[i], path[i + 1]
            if G.has_edge(a, b):
                edge_data = G.edges[a, b, 0]
                lst_start.append(a)
                lst_end.append(b)
                lst_length.append(round(edge_data.get('length', 0)))  # Handle missing length
                lst_time.append(round(edge_data.get('travel_time', 0)))  # Handle missing travel_time
                start_x.append(G.nodes[a]['x'])
                start_y.append(G.nodes[a]['y'])
                end_x.append(G.nodes[b]['x'])
                end_y.append(G.nodes[b]['y'])

    return pd.DataFrame({
        'start': lst_start,
        'end': lst_end,
        'length': lst_length,
        'travel_time': lst_time,
        'start_x': start_x,
        'start_y': start_y,
        'end_x': end_x,
        'end_y': end_y
    })

# Initialize DataFrame and append results
df = pd.DataFrame()
tmp = df_animation_multiple_path(G, lst_paths, parallel=False)
df = pd.concat([df, tmp], axis=0)

# Extract first and last nodes
first_node, last_node = lst_paths[0][0], lst_paths[-1][-1]

# Display DataFrame
print(df.head())

import osmnx as ox
import networkx as nx
import pandas as pd
import plotly.express as px

# Load a street network graph
G = ox.graph_from_place("Manhattan, New York, USA", network_type="drive")

# Add 'travel_time' attribute if missing
def add_travel_time(G, speed_kph=50):
    for u, v, k, data in G.edges(keys=True, data=True):
        if 'length' in data:
            speed_mps = speed_kph * 1000 / 3600
            data['travel_time'] = data['length'] / speed_mps

add_travel_time(G)

# Sample route (Modify as needed)
lst_route = list(G.nodes())[:5]

# Compute shortest paths
def get_path_between_nodes(lst_route, G):
    lst_paths = []
    for i in range(len(lst_route) - 1):
        try:
            a, b = lst_route[i], lst_route[i + 1]
            path = nx.shortest_path(G, source=a, target=b, method='dijkstra', weight='travel_time')
            if len(path) > 1:
                lst_paths.append(path)
        except nx.NetworkXNoPath:
            print(f"No path found between {a} and {b}")
            continue
        except Exception as e:
            print(f"Error finding path: {e}")
            continue
    return lst_paths

lst_paths = get_path_between_nodes(lst_route, G)

# Function to create DataFrame
def df_animation_multiple_path(G, lst_paths):
    lst_start, lst_end, lst_length, lst_time = [], [], [], []
    start_x, start_y, end_x, end_y = [], [], [], []
    ids = []  # Adding an 'id' column

    for path_idx, path in enumerate(lst_paths):
        for i in range(len(path) - 1):
            a, b = path[i], path[i + 1]
            if G.has_edge(a, b):
                edge_data = G.edges[a, b, 0]
                lst_start.append(a)
                lst_end.append(b)
                lst_length.append(round(edge_data.get('length', 0)))
                lst_time.append(round(edge_data.get('travel_time', 0)))
                start_x.append(G.nodes[a]['x'])
                start_y.append(G.nodes[a]['y'])
                end_x.append(G.nodes[b]['x'])
                end_y.append(G.nodes[b]['y'])
                ids.append(path_idx)  # Assign an ID based on path index

    return pd.DataFrame({
        'id': ids,  # New ID column
        'start': lst_start,
        'end': lst_end,
        'length': lst_length,
        'travel_time': lst_time,
        'start_x': start_x,
        'start_y': start_y,
        'end_x': end_x,
        'end_y': end_y
    })

# Create DataFrame with 'id' column
df = df_animation_multiple_path(G, lst_paths)

# Extract first and last nodes
first_node, last_node = lst_paths[0][0], lst_paths[-1][-1]

# Filter DataFrame for start and end nodes
df_start = df[df["start"] == first_node]
df_end = df[df["end"] == last_node]

# Plot Mapbox Visualization
fig = px.scatter_mapbox(
    data_frame=df, lon="start_x", lat="start_y", zoom=15, width=900, height=700,
    animation_frame="id",  # 'id' column now exists
    mapbox_style="carto-positron"
)

fig.data[0].marker = {"size": 12}

fig.add_trace(px.scatter_mapbox(data_frame=df, lon="start_x", lat="start_y").data[0])
fig.data[1].marker = {"size": 10, "color": "black"}

fig.add_trace(px.scatter_mapbox(data_frame=df_start, lon="start_x", lat="start_y").data[0])
fig.data[2].marker = {"size": 15, "color": "red"}

fig.add_trace(px.scatter_mapbox(data_frame=df_end, lon="start_x", lat="start_y").data[0])
fig.data[3].marker = {"size": 15, "color": "green"}

fig.add_trace(px.line_mapbox(data_frame=df, lon="start_x", lat="start_y").data[0])

fig

import osmnx as ox
import networkx as nx
import plotly.express as px
import pandas as pd

# Step 1: Load Hyderabad road network
city = "Hyderabad, India"
G = ox.graph_from_place(city, network_type="drive")

# Step 2: Extract nodes (important locations/intersections)
nodes, _ = ox.graph_to_gdfs(G)

# Step 3: Create a DataFrame for visualization
df = pd.DataFrame({'lat': nodes['y'], 'lon': nodes['x']})

# Step 4: Create an interactive Mapbox plot
fig = px.scatter_mapbox(
    df, lat="lat", lon="lon", zoom=11, width=900, height=600,
    mapbox_style="carto-positron",
    title="Hyderabad Road Network Map"
)

# Step 5: Show the map
fig.show()

!pip install ortools osmnx folium networkx geopandas shapely

import osmnx as ox
import networkx as nx
import folium
import numpy as np
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
import datetime

place = "Manhattan, New York, USA"
graph = ox.graph_from_place(place, network_type='drive')

# Add default edge speeds and compute travel times
graph = ox.add_edge_speeds(graph)          # adds 'speed_kph' attribute to edges
graph = ox.add_edge_travel_times(graph)    # adds 'travel_time' in seconds

# Example source and destination coordinates
locations = [
    (40.748817, -73.985428),  # Empire State Building
    (40.730610, -73.935242),  # East Village
    (40.706192, -74.008874)   # Wall Street
]

# Optional user preferences (weights)
user_preferences = {
    "avoid_highways": False,
    "prefer_quick_routes": True,
    "time_of_day": "08:00",  # morning peak
}

nodes = [ox.nearest_nodes(graph, lon, lat) for lat, lon in locations]

def compute_eta_matrix(graph, nodes, user_preferences):
    n = len(nodes)
    eta_matrix = np.zeros((n, n))

    for i in range(n):
        for j in range(n):
            if i == j:
                eta_matrix[i][j] = 0
            else:
                try:
                    # Shortest path using travel time
                    path = nx.shortest_path(graph, nodes[i], nodes[j], weight='travel_time')
                    travel_time = sum(graph[u][v][0].get('travel_time', 0) for u, v in zip(path[:-1], path[1:]))

                    # Factor in user preference for quick routes
                    if user_preferences["prefer_quick_routes"]:
                        eta_matrix[i][j] = travel_time
                    else:
                        distance = sum(graph[u][v][0].get('length', 0) for u, v in zip(path[:-1], path[1:]))
                        eta_matrix[i][j] = distance / 5.0  # assume avg. speed of 5 m/s
                except:
                    eta_matrix[i][j] = float('inf')
    return eta_matrix

def solve_tsp(distance_matrix):
    manager = pywrapcp.RoutingIndexManager(len(distance_matrix), 1, 0)
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_index, to_index):
        return int(distance_matrix[manager.IndexToNode(from_index)][manager.IndexToNode(to_index)])

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC

    solution = routing.SolveWithParameters(search_parameters)

    if solution:
        index = routing.Start(0)
        route = []
        while not routing.IsEnd(index):
            route.append(manager.IndexToNode(index))
            index = solution.Value(routing.NextVar(index))
        route.append(manager.IndexToNode(index))
        return route
    else:
        return None

def plot_route(graph, node_route):
    m = folium.Map(location=locations[0], zoom_start=13)

    for i in range(len(node_route) - 1):
        path = nx.shortest_path(graph, node_route[i], node_route[i+1], weight='travel_time')
        latlon = [(graph.nodes[n]['y'], graph.nodes[n]['x']) for n in path]
        folium.PolyLine(latlon, color='blue', weight=5).add_to(m)

    for i, node in enumerate(node_route):
        lat, lon = graph.nodes[node]['y'], graph.nodes[node]['x']
        folium.Marker([lat, lon], popup=f"Stop {i+1}").add_to(m)

    return m

eta_matrix = compute_eta_matrix(graph, nodes, user_preferences)
route = solve_tsp(eta_matrix)

if route:
    print("Optimized route:", route)
    display(plot_route(graph, [nodes[i] for i in route]))
else:
    print("No solution found.")

